
################################################################################################################
###                                                                                                          ###
### WARNING: This file is automatically generated DO NOT modify this file directly as it will be overwritten ###
###                                                                                                          ###
################################################################################################################

<#
.NOTES
    GitHub         : https://github.com/Joanty24/win-programarilliure
    Version        : 231001_1350
#>

Start-Transcript $ENV:TEMP\Winutil.log -Append

#Load DLLs
Add-Type -AssemblyName System.Windows.Forms

# variable to sync between runspaces
$sync = [Hashtable]::Synchronized(@{})
$sync.PSScriptRoot = $PSScriptRoot
$sync.version = "231001_1350"
$sync.configs = @{}
$sync.ProcessRunning = $false


if (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Output "La utilitat s'ha d'executar amb permis d'Administrador"
    break
}
Function Get-WinUtilCheckBoxes {

    <#

        .DESCRIPTION
        Function is meant to find all checkboxes that are checked on the specific tab and input them into a script.

        Outputed data will be the names of the checkboxes that were checked

        .EXAMPLE

        Get-WinUtilCheckBoxes "WPFInstall"

    #>

    Param(
        $Group,
        [boolean]$unCheck = $true
    )


    $Output = New-Object System.Collections.Generic.List[System.Object]

    if($Group -eq "WPFInstall"){
        $filter = Get-WinUtilVariables -Type Checkbox | Where-Object {$psitem -like "WPFInstall*"}
        $CheckBoxes = $sync.GetEnumerator() | Where-Object {$psitem.Key -in $filter}
        Foreach ($CheckBox in $CheckBoxes){
            if($CheckBox.value.ischecked -eq $true){
                $sync.configs.applications.$($CheckBox.Name).winget -split ";" | ForEach-Object {
                    $Output.Add($psitem)
                }
                if ($uncheck -eq $true){
                    $CheckBox.value.ischecked = $false
                }
                
            }
        }
    }
    
    if($Group -eq "WPFTweaks"){
        $filter = Get-WinUtilVariables -Type Checkbox | Where-Object {$psitem -like "WPF*Tweaks*"}
        $CheckBoxes = $sync.GetEnumerator() | Where-Object {$psitem.Key -in $filter}
        Foreach ($CheckBox in $CheckBoxes){
            if($CheckBox.value.ischecked -eq $true){
                $Output.Add($Checkbox.Name)
                
                if ($uncheck -eq $true){
                    $CheckBox.value.ischecked = $false
                }
            }
        }
    }

    if($Group -eq "WPFFeature"){
        $filter = Get-WinUtilVariables -Type Checkbox | Where-Object {$psitem -like "WPF*Feature*"}
        $CheckBoxes = $sync.GetEnumerator() | Where-Object {$psitem.Key -in $filter}
        Foreach ($CheckBox in $CheckBoxes){
            if($CheckBox.value.ischecked -eq $true){
                $Output.Add($Checkbox.Name)
                
                if ($uncheck -eq $true){
                    $CheckBox.value.ischecked = $false
                }
            }
        }
    }

    Write-Output $($Output | Select-Object -Unique)
}
function Get-WinUtilInstallerProcess {
    <#
    
        .DESCRIPTION
        Meant to check for running processes and will return a boolean response
    
    #>

    param($Process)

    if ($Null -eq $Process){
        return $false
    }
    if (Get-Process -Id $Process.Id -ErrorAction SilentlyContinue){
        return $true
    }
    return $false
}
function Get-WinUtilVariables {

    <#
    
        .DESCRIPTION
        placeholder
    
    #>
    param (
        [Parameter()]
        [ValidateSet("CheckBox", "Button")]
        [string]$Type
    )

    $keys = $sync.keys | Where-Object {$psitem -like "WPF*"} 

    if($type){
        $output = $keys | ForEach-Object {
            Try{
                if ($sync["$psitem"].GetType() -like "*$type*"){
                    Write-Output $psitem
                }
            }
            Catch{<#I am here so errors don't get outputted for a couple variables that don't have the .GetType() attribute#>}
        }
        return $output        
    }
    return $keys
}
Function Install-WinUtilProgramWinget {

    <#
    
        .DESCRIPTION
        This will install programs via Winget using a new powershell.exe instance to prevent the GUI from locking up.

        Note the triple quotes are required any time you need a " in a normal script block.
    
    #>

    param(
        $ProgramsToInstall,
        $manage = "Installing"
    )

    $x = 0
    $count = $($ProgramsToInstall -split ",").Count

    Write-Progress -Activity "$manage Applications" -Status "Starting" -PercentComplete 0

    Foreach ($Program in $($ProgramsToInstall -split ",")){
    
        Write-Progress -Activity "$manage Applications" -Status "$manage $Program $($x + 1) of $count" -PercentComplete $($x/$count*100)
        if($manage -eq "Installing"){
            Start-Process -FilePath winget -ArgumentList "install -e --accept-source-agreements --accept-package-agreements --silent $Program" -NoNewWindow -Wait
        }
        if($manage -eq "Uninstalling"){
            Start-Process -FilePath winget -ArgumentList "uninstall -e --purge --force --silent $Program" -NoNewWindow -Wait
        }
        
        $X++
    }

    Write-Progress -Activity "$manage Applications" -Status "Finished" -Completed

}
function Get-LatestHash {
    $shaUrl = ((Invoke-WebRequest $apiLatestUrl -UseBasicParsing | ConvertFrom-Json).assets | Where-Object { $_.name -match '^Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.txt$' }).browser_download_url
  
    $shaFile = Join-Path -Path $tempFolder -ChildPath 'Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.txt'
    $WebClient.DownloadFile($shaUrl, $shaFile)
  
    Get-Content $shaFile
  }

function Install-WinUtilWinget {
    
    <#
    
        .DESCRIPTION
        Function is meant to ensure winget is installed 
    
    #>
    Try{
        Write-Host "Checking if Winget is Installed..."
        if (Test-WinUtilPackageManager -winget) {
            #Checks if winget executable exists and if the Windows Version is 1809 or higher
            Write-Host "Winget Already Installed"
            return
        }

        #Gets the computer's information
        if ($null -eq $sync.ComputerInfo){
            $ComputerInfo = Get-ComputerInfo -ErrorAction Stop
        }
        Else {
            $ComputerInfo = $sync.ComputerInfo
        }

        if (($ComputerInfo.WindowsVersion) -lt "1809") {
            #Checks if Windows Version is too old for winget
            Write-Host "Winget is not supported on this version of Windows (Pre-1809)"
            return
        }

        Write-Host "Running Alternative Installer and Direct Installing"
        Start-Process -Verb runas -FilePath powershell.exe -ArgumentList "irm https://raw.githubusercontent.com/ChrisTitusTech/winutil/main/winget.ps1 | iex"
        
        Write-Host "Winget Installed"
    }
    Catch{
        throw [WingetFailedInstall]::new('Failed to install')
    }
}
Function Invoke-WinUtilCurrentSystem {

    <#

        .DESCRIPTION
        Function is meant to read existing system registry and check according configuration.

        Example: Is telemetry enabled? check the box.

        .EXAMPLE

        Get-WinUtilCheckBoxes "WPFInstall"

    #>

    param(
        $CheckBox
    )

    if ($checkbox -eq "winget"){

        $originalEncoding = [Console]::OutputEncoding
        [Console]::OutputEncoding = [System.Text.UTF8Encoding]::new()
        $Sync.InstalledPrograms = winget list -s winget | Select-Object -skip 3 | ConvertFrom-String -PropertyNames "Name", "Id", "Version", "Available" -Delimiter '\s{2,}'
        [Console]::OutputEncoding = $originalEncoding

        $filter = Get-WinUtilVariables -Type Checkbox | Where-Object {$psitem -like "WPFInstall*"}
        $sync.GetEnumerator() | Where-Object {$psitem.Key -in $filter} | ForEach-Object {
            $dependencies = @($sync.configs.applications.$($psitem.Key).winget -split ";")

            if ($dependencies[-1] -in $sync.InstalledPrograms.Id) {
                Write-Output $psitem.name
            }
        }
    }
}
function Invoke-WinUtilScript {
    <#
    
        .DESCRIPTION
        This function will run a separate powershell script. Meant for things that can't be handled with the other functions

        .EXAMPLE

        $Scriptblock = [scriptblock]::Create({"Write-output 'Hello World'"})
        Invoke-WinUtilScript -ScriptBlock $scriptblock -Name "Hello World"
    
    #>
    param (
        $Name,
        [scriptblock]$scriptblock
    )

    Try {
        Write-Host "Running Script for $name"
        Invoke-Command $scriptblock -ErrorAction Stop
    }
    Catch [System.Management.Automation.CommandNotFoundException] {
        Write-Warning "The specified command was not found."
        Write-Warning $PSItem.Exception.message
    }
    Catch [System.Management.Automation.RuntimeException] {
        Write-Warning "A runtime exception occurred."
        Write-Warning $PSItem.Exception.message
    }
    Catch [System.Security.SecurityException] {
        Write-Warning "A security exception occurred."
        Write-Warning $PSItem.Exception.message
    }
    Catch [System.UnauthorizedAccessException] {
        Write-Warning "Access denied. You do not have permission to perform this operation."
        Write-Warning $PSItem.Exception.message
    }
    Catch {
        # Generic catch block to handle any other type of exception
        Write-Warning "Unable to run script for $name due to unhandled exception"
        Write-Warning $psitem.Exception.StackTrace 
    }
    
}
function Remove-WinUtilAPPX {
    <#
    
        .DESCRIPTION
        This function will remove any of the provided APPX names

        .EXAMPLE

        Remove-WinUtilAPPX -Name "Microsoft.Microsoft3DViewer"
    
    #>
    param (
        $Name
    )

    Try{
        Write-Host "Removing $Name"
        Get-AppxPackage "*$Name*" | Remove-AppxPackage -ErrorAction SilentlyContinue
        Get-AppxProvisionedPackage -Online | Where-Object DisplayName -like "*$Name*" | Remove-AppxProvisionedPackage -Online -ErrorAction SilentlyContinue
    }
    Catch [System.Exception] {
        if($psitem.Exception.Message -like "*The requested operation requires elevation*"){
            Write-Warning "Unable to uninstall $name due to a Security Exception"
        }
        Else{
            Write-Warning "Unable to uninstall $name due to unhandled exception"
            Write-Warning $psitem.Exception.StackTrace 
        }
    }
    Catch{
        Write-Warning "Unable to uninstall $name due to unhandled exception"
        Write-Warning $psitem.Exception.StackTrace 
    }
}
function Set-WinUtilRestorePoint {
    <#
    
        .DESCRIPTION
        This function will make a Restore Point

    #>    

    # Check if the user has administrative privileges
    if (-Not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
        Write-Host "Please run this script as an administrator."
        return
    }

    # Check if System Restore is enabled for the main drive
    try {
        # Try getting restore points to check if System Restore is enabled
        Enable-ComputerRestore -Drive "$env:SystemDrive"
    } catch {
        Write-Host "An error occurred while enabling System Restore: $_"
    }

    # Check if the SystemRestorePointCreationFrequency value exists
    $exists = Get-ItemProperty -path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SystemRestore" -name "SystemRestorePointCreationFrequency" -ErrorAction SilentlyContinue
    if($null -eq $exists){
        write-host 'Changing system to allow multiple restore points per day'
        Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SystemRestore" -Name "SystemRestorePointCreationFrequency" -Value "0" -Type DWord -Force -ErrorAction Stop | Out-Null  
    }

    # Get all the restore points for the current day
    $existingRestorePoints = Get-ComputerRestorePoint | Where-Object { $_.CreationTime.Date -eq (Get-Date).Date }

    # Check if there is already a restore point created today
    if ($existingRestorePoints.Count -eq 0) {
        $description = "System Restore Point created by WinUtil"
        
        Checkpoint-Computer -Description $description -RestorePointType "MODIFY_SETTINGS"
        Write-Host -ForegroundColor Green "System Restore Point Created Successfully"
    }
}
function Set-WinUtilScheduledTask {
    <#
    
        .DESCRIPTION
        This function will enable/disable the provided Scheduled Task

        .EXAMPLE

        Set-WinUtilScheduledTask -Name "Microsoft\Windows\Application Experience\Microsoft Compatibility Appraiser" -State "Disabled"
    
    #>
    param (
        $Name,
        $State
    )

    Try{
        if($State -eq "Disabled"){
            Write-Host "Disabling Scheduled Task $Name"
            Disable-ScheduledTask -TaskName $Name -ErrorAction Stop
        }
        if($State -eq "Enabled"){
            Write-Host "Enabling Scheduled Task $Name"
            Enable-ScheduledTask -TaskName $Name -ErrorAction Stop
        }
    }
    Catch [System.Exception]{
        if($psitem.Exception.Message -like "*The system cannot find the file specified*"){
            Write-Warning "Scheduled Task $name was not Found"
        }
        Else{
            Write-Warning "Unable to set $Name due to unhandled exception"
            Write-Warning $psitem.Exception.Message
        }
    }
    Catch{
        Write-Warning "Unable to run script for $name due to unhandled exception"
        Write-Warning $psitem.Exception.StackTrace 
    }
}
Function Set-WinUtilService {
    <#
    
        .DESCRIPTION
        This function will change the startup type of services and start/stop them as needed

        .EXAMPLE

        Set-WinUtilService -Name "HomeGroupListener" -StartupType "Manual"
    
    #>   
    param (
        $Name,
        $StartupType
    )
    try {
        Write-Host "Setting Service $Name to $StartupType"
    
        # Check if the service exists
        $service = Get-Service -Name $Name -ErrorAction Stop
    
        # Service exists, proceed with changing properties
        $service | Set-Service -StartupType $StartupType -ErrorAction Stop
    }
    catch [System.ServiceProcess.ServiceNotFoundException] {
        Write-Warning "Service $Name was not found"
    }
    catch {
        Write-Warning "Unable to set $Name due to unhandled exception"
        Write-Warning $_.Exception.Message
    }
    
}
function Set-WinUtilUITheme {
    <#
    
        .DESCRIPTION
        This function will set theme to the XAML file

        .EXAMPLE

        Set-WinUtilUITheme -inputXAML $inputXAML
    
    #>
    param
    (
         [Parameter(Mandatory=$true, Position=0)]
         [string] $inputXML,
         [Parameter(Mandatory=$false, Position=1)]
         [string] $themeName = 'matrix'
    )

    try {
        # Convert the JSON to a PowerShell object
        $themes = $sync.configs.themes
        # Select the specified theme
        $selectedTheme = $themes.$themeName

        if ($selectedTheme) {
            # Loop through all key-value pairs in the selected theme
            foreach ($property in $selectedTheme.PSObject.Properties) {
                $key = $property.Name
                $value = $property.Value
                # Add curly braces around the key
                $formattedKey = "{$key}"
                # Replace the key with the value in the input XML
                $inputXML = $inputXML.Replace($formattedKey, $value)
            }
        }
        else {
            Write-Host "Theme '$themeName' not found."
        }

    }
    catch {
        Write-Warning "Unable to apply theme"
        Write-Warning $psitem.Exception.StackTrace 
    }

    return $inputXML;
}
function Test-WinUtilPackageManager {
    <#
    
        .DESCRIPTION
        Checks for Winget or Choco depending on the parameter
    
    #>

    Param(
        [System.Management.Automation.SwitchParameter]$winget
    )

    if($winget){
        if (Test-Path ~\AppData\Local\Microsoft\WindowsApps\winget.exe) {
            return $true
        }
    }

    return $false
}
Function Update-WinUtilProgramWinget {

    <#
    
        .DESCRIPTION
        This will update programs via Winget using a new powershell.exe instance to prevent the GUI from locking up.
    
    #>

    [ScriptBlock]$wingetinstall = {

        $host.ui.RawUI.WindowTitle = """Winget Install"""

        Start-Transcript $ENV:TEMP\winget-update.log -Append
        winget upgrade --all

        Pause
    }

    $global:WinGetInstall = Start-Process -Verb runas powershell -ArgumentList "-command invoke-command -scriptblock {$wingetinstall} -argumentlist '$($ProgramsToInstall -join ",")'" -PassThru

}
function Invoke-WPFButton {

    <#
    
        .DESCRIPTION
        Meant to make creating buttons easier. There is a section below in the gui that will assign this function to every button.
        This way you can dictate what each button does from this function. 
    
        Input will be the name of the button that is clicked. 
    #>
    
    Param ([string]$Button) 

    #Use this to get the name of the button
    #[System.Windows.MessageBox]::Show("$Button","Chris Titus Tech's Windows Utility","OK","Info")

    Switch -Wildcard ($Button){

        "WPFTab?BT" {Invoke-WPFTab $Button}
        "WPFinstall" {Invoke-WPFInstall}
        "WPFuninstall" {Invoke-WPFUnInstall}
        "WPFInstallUpgrade" {Invoke-WPFInstallUpgrade}
        "WPFdesktop" {Invoke-WPFPresets "Desktop"}
        "WPFlaptop" {Invoke-WPFPresets "laptop"}
        "WPFminimal" {Invoke-WPFPresets "minimal"}
        "WPFexport" {Invoke-WPFImpex -type "export" -CheckBox "WPFTweaks"}
        "WPFimport" {Invoke-WPFImpex -type "import" -CheckBox "WPFTweaks"}
        "WPFexportWinget" {Invoke-WPFImpex -type "export" -CheckBox "WPFInstall"}
        "WPFimportWinget" {Invoke-WPFImpex -type "import" -CheckBox "WPFInstall"}
        "WPFclear" {Invoke-WPFPresets -preset $null -imported $true}
        "WPFclearWinget" {Invoke-WPFPresets -preset $null -imported $true -CheckBox "WPFInstall"}
        "WPFtweaksbutton" {Invoke-WPFtweaksbutton}
        "WPFAddUltPerf" {Invoke-WPFUltimatePerformance -State "Enabled"}
        "WPFRemoveUltPerf" {Invoke-WPFUltimatePerformance -State "Disabled"}
        "WPFToggleDarkMode" {Invoke-WPFDarkMode -DarkMoveEnabled $(Get-WinUtilDarkMode)}
        "WPFundoall" {Invoke-WPFundoall}
        "WPFFeatureInstall" {Invoke-WPFFeatureInstall}
        "WPFPanelDISM" {Invoke-WPFPanelDISM}
        "WPFPanelAutologin" {Invoke-WPFPanelAutologin}
        "WPFPanelcontrol" {Invoke-WPFControlPanel -Panel $button}
        "WPFPanelnetwork" {Invoke-WPFControlPanel -Panel $button}
        "WPFPanelpower" {Invoke-WPFControlPanel -Panel $button}
        "WPFPanelregion" {Invoke-WPFControlPanel -Panel $button}
        "WPFPanelsound" {Invoke-WPFControlPanel -Panel $button}
        "WPFPanelsystem" {Invoke-WPFControlPanel -Panel $button}
        "WPFPaneluser" {Invoke-WPFControlPanel -Panel $button}
        "WPFUpdatesdefault" {Invoke-WPFUpdatesdefault}
        "WPFFixesUpdate" {Invoke-WPFFixesUpdate}
        "WPFFixesNetwork" {Invoke-WPFFixesNetwork}
        "WPFUpdatesdisable" {Invoke-WPFUpdatesdisable}
        "WPFUpdatessecurity" {Invoke-WPFUpdatessecurity}
        "WPFWinUtilShortcut" {Invoke-WPFShortcut -ShortcutToAdd "WinUtil"}
        "WPFGetInstalled" {Invoke-WPFGetInstalled -CheckBox "winget"}
        "WPFGetInstalledTweaks" {Invoke-WPFGetInstalled -CheckBox "tweaks"}
    }
}
function Invoke-WPFFeatureInstall {
        <#
    
        .DESCRIPTION
        GUI Function to install Windows Features
    
    #>

    if($sync.ProcessRunning){
        $msg = "Install process is currently running."
        [System.Windows.MessageBox]::Show($msg, "Winutil", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    $Features = Get-WinUtilCheckBoxes -Group "WPFFeature"

    Invoke-WPFRunspace -ArgumentList $Features -ScriptBlock {
        param($Features)

        $sync.ProcessRunning = $true

        Invoke-WinUtilFeatureInstall $Features

        $sync.ProcessRunning = $false
        Write-Host "==================================="
        Write-Host "---   Features are Installed    ---"
        Write-Host "---  A Reboot may be required   ---"
        Write-Host "==================================="
    
        $ButtonType = [System.Windows.MessageBoxButton]::OK
        $MessageboxTitle = "All features are now installed "
        $Messageboxbody = ("Done")
        $MessageIcon = [System.Windows.MessageBoxImage]::Information
    
        [System.Windows.MessageBox]::Show($Messageboxbody, $MessageboxTitle, $ButtonType, $MessageIcon)
    }
}
function Invoke-WPFFormVariables{
Write-Host ""
Write-Host ""
Write-Host "    d88b  .d88b.   .d8b.  d8b   db "
Write-Host "     8P' .8P  Y8. d8'  8b 888o  88 "
Write-Host "     88  88    88 88ooo88 88V8o 88 "
Write-Host "     88  88    88 88~~~88 88 V8o88 "
Write-Host " db. 88   8b  d8' 88   88 88  V888 "
Write-Host " Y8888P    Y88P'  YP   YP VP   V8P "
Write-Host ""
Write-Host "     d888888b d8888b. d8888b.      "
Write-Host "      ~~88~~' 88   8D 88   8D      "
Write-Host "        88    88   88 88oobY'      "
Write-Host "        88    88   88 88 8b        "
Write-Host "        88    88  .8D 88  88.      "
Write-Host "        YP    Y8888D' 88   YD      "
Write-Host ""
Write-Host ""
}
function Invoke-WPFGetInstalled {
    <#

    .DESCRIPTION
    placeholder

    #>
    param($checkbox)

    if($sync.ProcessRunning){
        $msg = "Install process is currently running."
        [System.Windows.MessageBox]::Show($msg, "Winutil", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    if(!(Test-WinUtilPackageManager -winget) -and $checkbox -eq "winget"){
        Write-Host "==========================================="
        Write-Host "--       Winget is not installed        ---"
        Write-Host "==========================================="
        return
    }

    Invoke-WPFRunspace -ArgumentList $checkbox -ScriptBlock {
        param($checkbox)

        $sync.ProcessRunning = $true

        if($checkbox -eq "winget"){
            Write-Host "Getting Installed Programs..."
        }
        if($checkbox -eq "tweaks"){
            Write-Host "Getting Installed Tweaks..."
        }
        
        $Checkboxes = Invoke-WinUtilCurrentSystem -CheckBox $checkbox
        
        $sync.form.Dispatcher.invoke({
            foreach($checkbox in $Checkboxes){
                $sync.$checkbox.ischecked = $True
            }
        })

        Write-Host "Done..."
        $sync.ProcessRunning = $false
    }
}
function Invoke-WPFInstall {
    <#
    
        .DESCRIPTION
        PlaceHolder
    
    #>

    if($sync.ProcessRunning){
        $msg = "Install process is currently running."
        [System.Windows.MessageBox]::Show($msg, "Winutil", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    $WingetInstall = Get-WinUtilCheckBoxes -Group "WPFInstall"

    if ($wingetinstall.Count -eq 0) {
        $WarningMsg = "Please select the program(s) to install"
        [System.Windows.MessageBox]::Show($WarningMsg, $AppTitle, [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    Invoke-WPFRunspace -ArgumentList $WingetInstall -scriptblock {
        param($WingetInstall)
        try{
            $sync.ProcessRunning = $true

            # Ensure winget is installed
            Install-WinUtilWinget

            # Install all winget programs in new window
            Install-WinUtilProgramWinget -ProgramsToInstall $WingetInstall

            $ButtonType = [System.Windows.MessageBoxButton]::OK
            $MessageboxTitle = "Installs are Finished "
            $Messageboxbody = ("Done")
            $MessageIcon = [System.Windows.MessageBoxImage]::Information
        
            [System.Windows.MessageBox]::Show($Messageboxbody, $MessageboxTitle, $ButtonType, $MessageIcon)

            Write-Host "==========================================="
            Write-Host "--      Installs have finished          ---"
            Write-Host "==========================================="
        }
        Catch {
            Write-Host "==========================================="
            Write-Host "--      Winget failed to install        ---"
            Write-Host "==========================================="
        }
        $sync.ProcessRunning = $False
    }
}
function Invoke-WPFInstallUpgrade {
    <#
    
        .DESCRIPTION
        PlaceHolder
    
    #>
    if(!(Test-WinUtilPackageManager -winget)){
        Write-Host "==========================================="
        Write-Host "--       Winget is not installed        ---"
        Write-Host "==========================================="
        return
    }

    if(Get-WinUtilInstallerProcess -Process $global:WinGetInstall){
        $msg = "Install process is currently running. Please check for a powershell window labeled 'Winget Install'"
        [System.Windows.MessageBox]::Show($msg, "Winutil", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    Update-WinUtilProgramWinget

    Write-Host "==========================================="
    Write-Host "--           Updates started            ---"
    Write-Host "-- You can close this window if desired ---"
    Write-Host "==========================================="
}
function Invoke-WPFPresets {
    <#

        .DESCRIPTION
        Meant to make settings presets easier in the tweaks tab. Will pull the data from config/preset.json

    #>

    param(
        $preset,
        [bool]$imported = $false,
        $checkbox = "WPFTweaks"
    )

    if($imported -eq $true){
        $CheckBoxesToCheck = $preset
    }
    Else{
        $CheckBoxesToCheck = $sync.configs.preset.$preset
    }

    if($checkbox -eq "WPFTweaks"){
        $filter = Get-WinUtilVariables -Type Checkbox | Where-Object {$psitem -like "*tweaks*"}
        $sync.GetEnumerator() | Where-Object {$psitem.Key -in $filter} | ForEach-Object {
            if ($CheckBoxesToCheck -contains $PSItem.name){
                $sync.$($PSItem.name).ischecked = $true
            }
            else{$sync.$($PSItem.name).ischecked = $false}
        }
    }
    if($checkbox -eq "WPFInstall"){

        $filter = Get-WinUtilVariables -Type Checkbox | Where-Object {$psitem -like "WPFInstall*"}
        $sync.GetEnumerator() | Where-Object {$psitem.Key -in $filter} | ForEach-Object {
            if($($sync.configs.applications.$($psitem.name).winget) -in $CheckBoxesToCheck){
                $sync.$($PSItem.name).ischecked = $true
            }
            else{$sync.$($PSItem.name).ischecked = $false}
        }
    }
}
function Invoke-WPFRunspace {

    <#
    
        .DESCRIPTION
        Simple function to make it easier to invoke a runspace from inside the script. 

        .EXAMPLE

        $params = @{
            ScriptBlock = $sync.ScriptsInstallPrograms
            ArgumentList = "Installadvancedip,Installbitwarden"
            Verbose = $true
        }

        Invoke-WPFRunspace @params
    
    #>

    [CmdletBinding()]
    Param (
        $ScriptBlock,
        $ArgumentList
    ) 

    #Crate a PowerShell instance.
    $script:powershell = [powershell]::Create()

    #Add Scriptblock and Arguments to runspace
    $script:powershell.AddScript($ScriptBlock)
    $script:powershell.AddArgument($ArgumentList)
    $script:powershell.RunspacePool = $sync.runspace
    
    #Run our RunspacePool.
    $script:handle = $script:powershell.BeginInvoke()

    #Cleanup our RunspacePool threads when they are complete ie. GC.
    if ($script:handle.IsCompleted)
    {
        $script:powershell.EndInvoke($script:handle)
        $script:powershell.Dispose()
        $sync.runspace.Dispose()
        $sync.runspace.Close()
        [System.GC]::Collect()
    }
}
function Invoke-WPFTab {

    <#
    
        .DESCRIPTION
        Sole purpose of this function is to reduce duplicated code for switching between tabs. 
    
    #>

    Param ($ClickedTab)
    $Tabs = Get-WinUtilVariables | Where-Object {$psitem -like "WPFTab?BT"}
    $TabNav = Get-WinUtilVariables | Where-Object {$psitem -like "WPFTabNav"}
    $x = [int]($ClickedTab -replace "WPFTab","" -replace "BT","") - 1

    0..($Tabs.Count -1 ) | ForEach-Object {
        
        if ($x -eq $psitem){
            $sync.$TabNav.Items[$psitem].IsSelected = $true
        }
        else{
            $sync.$TabNav.Items[$psitem].IsSelected = $false
        }
    }
}
function Invoke-WPFUnInstall {
    <#
    
        .DESCRIPTION
        PlaceHolder
    
    #>

    if($sync.ProcessRunning){
        $msg = "Install process is currently running."
        [System.Windows.MessageBox]::Show($msg, "Winutil", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    $WingetInstall = Get-WinUtilCheckBoxes -Group "WPFInstall"

    if ($wingetinstall.Count -eq 0) {
        $WarningMsg = "Please select the program(s) to install"
        [System.Windows.MessageBox]::Show($WarningMsg, $AppTitle, [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    $ButtonType = [System.Windows.MessageBoxButton]::YesNo
    $MessageboxTitle = "Are you sure?"
    $Messageboxbody = ("This will uninstall the following applications `n $WingetInstall")
    $MessageIcon = [System.Windows.MessageBoxImage]::Information

    $confirm = [System.Windows.MessageBox]::Show($Messageboxbody, $MessageboxTitle, $ButtonType, $MessageIcon)

    if($confirm -eq "No"){return}

    Invoke-WPFRunspace -ArgumentList $WingetInstall -scriptblock {
        param($WingetInstall)
        try{
            $sync.ProcessRunning = $true

            # Install all winget programs in new window
            Install-WinUtilProgramWinget -ProgramsToInstall $WingetInstall -Manage "Uninstalling"

            $ButtonType = [System.Windows.MessageBoxButton]::OK
            $MessageboxTitle = "Uninstalls are Finished "
            $Messageboxbody = ("Done")
            $MessageIcon = [System.Windows.MessageBoxImage]::Information
        
            [System.Windows.MessageBox]::Show($Messageboxbody, $MessageboxTitle, $ButtonType, $MessageIcon)

            Write-Host "==========================================="
            Write-Host "--      Uninstalls have finished          ---"
            Write-Host "==========================================="
        }
        Catch {
            Write-Host "==========================================="
            Write-Host "--      Winget failed to install        ---"
            Write-Host "==========================================="
        }
        $sync.ProcessRunning = $False
    }
}
$inputXML = '<Window x:Class="WinUtility.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WinUtility"
        mc:Ignorable="d"
        Background="{MainBackgroundColor}"
        WindowStartupLocation="CenterScreen"
        Title="Open Windows Utility" Height="650" Width="1050">
    <Window.Resources>
        <Style TargetType="ComboBox">
            <Setter Property="Foreground" Value="{ComboBoxForegroundColor}"/>
            <Setter Property="Background" Value="{ComboBoxBackgroundColor}"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="ComboBox">
                        <Grid>
                            <ToggleButton x:Name="ToggleButton"
                                          Background="{TemplateBinding Background}"
                                          BorderBrush="{TemplateBinding Background}"
                                          BorderThickness="0"
                                          IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                                          ClickMode="Press">
                                <TextBlock Text="{TemplateBinding SelectionBoxItem}"
                                           Foreground="{TemplateBinding Foreground}"
                                           Background="{TemplateBinding Background}"
                                           />
                            </ToggleButton>
                            <Popup x:Name="Popup"
                                   IsOpen="{TemplateBinding IsDropDownOpen}"
                                   Placement="Bottom"
                                   Focusable="False"
                                   AllowsTransparency="True"
                                   PopupAnimation="Slide">
                                <Border x:Name="DropDownBorder"
                                        Background="{TemplateBinding Background}"
                                        BorderBrush="{TemplateBinding Foreground}"
                                        BorderThickness="1"
                                        CornerRadius="4">
                                    <ScrollViewer>
                                        <ItemsPresenter/>
                                    </ScrollViewer>
                                </Border>
                            </Popup>
                        </Grid>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        <Style TargetType="Label">
            <Setter Property="Foreground" Value="{LabelboxForegroundColor}"/>
            <Setter Property="Background" Value="{LabelBackgroundColor}"/>
        </Style>
        <Style TargetType="TextBlock">
            <Setter Property="Foreground" Value="{LabelboxForegroundColor}"/>
            <Setter Property="Background" Value="{LabelBackgroundColor}"/>
        </Style>
        <Style TargetType="Button">
            <Setter Property="Foreground" Value="{ButtonForegroundColor}"/>
            <Setter Property="Background" Value="{ButtonBackgroundColor}"/>
            <Setter Property="Margin" Value="{ButtonMargin}"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Grid>
                            <Border x:Name="BackgroundBorder"
                                    Background="{TemplateBinding Background}"
                                    BorderBrush="{TemplateBinding BorderBrush}"
                                    BorderThickness="{ButtonBorderThickness}"
                                    CornerRadius="{ButtonCornerRadius}">
                                <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                            </Border>
                        </Grid>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsPressed" Value="True">
                                <Setter TargetName="BackgroundBorder" Property="Background" Value="{ButtonBackgroundPressedColor}"/>
                            </Trigger>
                             <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="BackgroundBorder" Property="Background" Value="{ButtonBackgroundMouseoverColor}"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter TargetName="BackgroundBorder" Property="Background" Value="Gray"/>
                                <Setter Property="Foreground" Value="DimGray"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        <Style TargetType="CheckBox">
            <Setter Property="Foreground" Value="{MainForegroundColor}"/>
            <Setter Property="Background" Value="{MainBackgroundColor}"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="CheckBox">
                        <Grid Background="{TemplateBinding Background}">
                            <BulletDecorator Background="Transparent">
                                <BulletDecorator.Bullet>
                                    <Grid Width="16" Height="16">
                                        <Border x:Name="Border"
                                                BorderBrush="{TemplateBinding BorderBrush}"
                                                Background="{ButtonBackgroundColor}"
                                                BorderThickness="1"
                                                Width="14"
                                                Height="14"
                                                Margin="1"
                                                SnapsToDevicePixels="True"/>
                                        <Path x:Name="CheckMark"
                                              Stroke="{TemplateBinding Foreground}"
                                              StrokeThickness="2"
                                              Data="M 0 5 L 5 10 L 12 0"
                                              Visibility="Collapsed"/>
                                    </Grid>
                                </BulletDecorator.Bullet>
                                <ContentPresenter Margin="4,0,0,0"
                                                  HorizontalAlignment="Left"
                                                  VerticalAlignment="Center"
                                                  RecognizesAccessKey="True"/>
                            </BulletDecorator>
                        </Grid>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsChecked" Value="True">
                                <Setter TargetName="CheckMark" Property="Visibility" Value="Visible"/>
                            </Trigger>
                            <Trigger Property="IsMouseOver" Value="True">
                                    <!--Setter TargetName="Border" Property="Background" Value="{ButtonBackgroundPressedColor}"/-->
                                    <Setter Property="Foreground" Value="{ButtonBackgroundPressedColor}"/>
                                </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                 </Setter.Value>
            </Setter>
        </Style>        
        <Style x:Key="ToggleSwitchStyle" TargetType="CheckBox">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="CheckBox">
                        <StackPanel>
                            <Grid>
                                <Border Width="45" 
                                        Height="20"
                                        Background="#555555" 
                                        CornerRadius="10" 
                                        Margin="5,0"
                                />
                                <Border Name="WPFToggleSwitchButton"
                                        Width="25" 
                                        Height="25"
                                        Background="Black" 
                                        CornerRadius="12.5" 
                                        HorizontalAlignment="Left"
                                />
                                <ContentPresenter Name="WPFToggleSwitchContent"
                                                  Margin="10,0,0,0"
                                                  Content="{TemplateBinding Content}"
                                                  VerticalAlignment="Center"
                                />
                            </Grid>
                        </StackPanel>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsChecked" Value="false">
                                <Trigger.ExitActions>
                                    <RemoveStoryboard BeginStoryboardName="WPFToggleSwitchLeft"/>
                                    <BeginStoryboard x:Name="WPFToggleSwitchRight">
                                        <Storyboard>
                                            <ThicknessAnimation Storyboard.TargetProperty="Margin"
                                                    Storyboard.TargetName="WPFToggleSwitchButton"
                                                    Duration="0:0:0:0"
                                                    From="0,0,0,0"
                                                    To="28,0,0,0">
                                            </ThicknessAnimation>
                                        </Storyboard>
                                    </BeginStoryboard>
                                </Trigger.ExitActions>
                                <Setter TargetName="WPFToggleSwitchButton"
                                        Property="Background"
                                        Value="#fff9f4f4"
                                />
                            </Trigger>
                            <Trigger Property="IsChecked" Value="true">
                                <Trigger.ExitActions>
                                    <RemoveStoryboard BeginStoryboardName="WPFToggleSwitchRight"/>
                                    <BeginStoryboard x:Name="WPFToggleSwitchLeft">
                                        <Storyboard>
                                            <ThicknessAnimation Storyboard.TargetProperty="Margin"
                                                    Storyboard.TargetName="WPFToggleSwitchButton"
                                                    Duration="0:0:0:0"
                                                    From="28,0,0,0"
                                                    To="0,0,0,0">
                                            </ThicknessAnimation>
                                        </Storyboard>
                                    </BeginStoryboard>
                                </Trigger.ExitActions>
                                <Setter TargetName="WPFToggleSwitchButton"
                                        Property="Background"
                                        Value="#ff060600"
                                />
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Window.Resources>
    <Border Name="WPFdummy" Grid.Column="0" Grid.Row="1">
        <Viewbox Stretch="Uniform" VerticalAlignment="Top">
            <Grid Background="{MainBackgroundColor}" ShowGridLines="False" Name="WPFMainGrid">
                <Grid.RowDefinitions>
                    <RowDefinition Height=".1*"/>
                    <RowDefinition Height=".9*"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <TabControl Grid.Row="1" Padding="-1" Name="WPFTabNav" Background="#222222">
                    <TabItem Header="Install" Visibility="Collapsed" Name="WPFTab1">
                        <Grid Background="#222222">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            <Grid.RowDefinitions>
                                <RowDefinition Height=".10*"/>
                                <RowDefinition Height=".90*"/>
                            </Grid.RowDefinitions>
                            <StackPanel Background="{MainBackgroundColor}" Orientation="Horizontal" Grid.Row="0" HorizontalAlignment="Center" Grid.Column="0" Grid.ColumnSpan="2" Margin="8">
                                <Button Name="WPFinstall" Content=" Instal.la Seleccio " Margin="7"/>
                                <Button Name="WPFInstallUpgrade" Content=" Actualitza Tot " Margin="7"/>
                                <Button Name="WPFuninstall" Content=" Desinstal.la Seleccio " Margin="7"/>
                                <Button Name="WPFGetInstalled" Content=" Instal.lats Ara " Margin="7"/>
                                <Button Name="WPFclearWinget" Content=" Esclarir Seleccio " Margin="7"/>
                            </StackPanel>
                            <StackPanel Background="{MainBackgroundColor}" SnapsToDevicePixels="True" Grid.Row="1" Grid.Column="0" Margin="9">
                                <Label Content="Navegadors" FontSize="16" Margin="5,0"/>
                                <CheckBox Name="WPFInstallfirefox" Content="Firefox" Margin="5,0" ToolTip="Navegador Mozilla Firefox"/>
                                <CheckBox Name="WPFInstalllibrewolf" Content="Librewolf" Margin="5,0" ToolTip="Navegador basat en Firefox amb bloquejador d''anuncis centrat en la privacitat"/>
                                <CheckBox Name="WPFInstallchromium" Content="ungoogled-chromium" Margin="5,0" ToolTip="Versio lliure i sense Google de Google Chrome"/>
                                <CheckBox Name="WPFInstallbrave" Content="Brave" Margin="5,0" ToolTip="Navegador basat en Chromium amb bloquejador d''anuncis"/>
                                <Label Content="Oficina" FontSize="16" Margin="5,0"/>
                                <CheckBox Name="WPFInstallonlyoffice" Content="ONLYOFFICE Desktop" Margin="5,0" ToolTip="Conjunt d''ofimatica compatible amb Microsoft Office"/>
                                <CheckBox Name="WPFInstalllibreoffice" Content="LibreOffice" Margin="5,0" ToolTip="Conjunt d''ofimatica lliure"/>
                                <CheckBox Name="WPFInstallwinmerge" Content="WinMerge" Margin="5,0" ToolTip="Comparador de fitxers de text"/>
                                <CheckBox Name="WPFInstallscribus" Content="Scribus" Margin="5,0" ToolTip="Programa editorial"/>
                                <CheckBox Name="WPFInstallsumatra" Content="Sumatra PDF" Margin="5,0" ToolTip="Visualitzador PDF"/>
                                <CheckBox Name="WPFInstalljoplin" Content="Joplin" Margin="5,0" ToolTip="Notes"/>
                            </StackPanel>
                            <StackPanel Background="{MainBackgroundColor}" SnapsToDevicePixels="True" Grid.Row="1" Grid.Column="1" Margin="9">
                                <Label Content="Multimedia" FontSize="16" Margin="5,0"/>
                                <CheckBox Name="WPFInstallvlc" Content="VLC" Margin="5,0" ToolTip="Reproductor multimedia"/>
                                <CheckBox Name="WPFInstallobs" Content="OBS Studio" Margin="5,0" ToolTip="Capturador de pantalla"/>
                                <CheckBox Name="WPFInstallspotube" Content="Spotube" Margin="5,0" ToolTip="Reproductor per Spotify"/>
                                <CheckBox Name="WPFInstallcider" Content="Cider" Margin="5,0" ToolTip="Reproductor per Apple Music"/>
                                <CheckBox Name="WPFInstalldownloader" Content="Xtreme Download Manager" Margin="5,0" ToolTip="Baixador de fitxers d''internet"/>
                                <CheckBox Name="WPFInstallaudacity" Content="Audacity" Margin="5,0" ToolTip="Editor d''audio"/>
                                <CheckBox Name="WPFInstallgimp" Content="GIMP" Margin="5,0" ToolTip="Editor d''imatges"/>
                                <CheckBox Name="WPFInstallkrita" Content="Krita" Margin="5,0" ToolTip="Editor d''imatges"/>
                                <CheckBox Name="WPFInstalldarktable" Content="Darktable" Margin="5,0" ToolTip="Editor de fotografies"/>
                                <CheckBox Name="WPFInstallinkscape" Content="Inkscape" Margin="5,0" ToolTip="Editor vectorial"/>
                                <CheckBox Name="WPFInstallcaesium" Content="Caesium" Margin="5,0" ToolTip="Compressor d''imatges"/>
                                <CheckBox Name="WPFInstallkdenlive" Content="Kdenlive" Margin="5,0" ToolTip="Editor de video"/>
                                <CheckBox Name="WPFInstallhandbrake" Content="Handbrake" Margin="5,0" ToolTip="Codificador de video"/>
                                <CheckBox Name="WPFInstallblender" Content="Blender" Margin="5,0" ToolTip="Creador multimedia"/>
                                <CheckBox Name="WPFInstallfreecad" Content="FreeCAD" Margin="5,0" ToolTip="CAD lliure"/>
                            </StackPanel>
                            <StackPanel Background="{MainBackgroundColor}" SnapsToDevicePixels="True" Grid.Row="1" Grid.Column="2" Margin="9">
                                <Label Content="Programacio" FontSize="16" Margin="5,0"/>
                                <CheckBox Name="WPFInstallcodium" Content="VSCodium" Margin="5,0" ToolTip="Editor de codi complet"/>
                                <CheckBox Name="WPFInstallnotepad" Content="Notepad++" Margin="5,0" ToolTip="Editor de codi simple"/>
                                <Label Content="Jocs" FontSize="16" Margin="5,0"/>
                                <CheckBox Name="WPFInstallplaynite" Content="Playnite" Margin="5,0" ToolTip="Llan??ador de jocs"/>
                                <CheckBox Name="WPFInstallheroic" Content="Heroic Games Launcher" Margin="5,0" ToolTip="Llan??ador de jocs"/>
                                <CheckBox Name="WPFInstallitchio" Content="itch.io" Margin="5,0" ToolTip="Llan??ador de jocs"/>
                                <Label Content="Seguretat" FontSize="16" Margin="5,0"/>
                                <CheckBox Name="WPFInstallclamwin" Content="ClamWin" Margin="5,0" ToolTip="Antivirus"/>
                                <CheckBox Name="WPFInstalleraser" Content="Eraser Classic" Margin="5,0" ToolTip="Elimina fitxers sense deixar rastre"/>
                                <CheckBox Name="WPFInstallchecksum" Content="OpenHashTab" Margin="5,0" ToolTip="Comprovador de hash"/>
                                <CheckBox Name="WPFInstallkeepass" Content="KeePassXC" Margin="5,0" ToolTip="desador de contrassenyes"/>
                                <CheckBox Name="WPFInstallsandbox" Content="Sandbobie Plus" Margin="5,0" ToolTip="Permet executar programes de manera segura"/>
                                <CheckBox Name="WPFInstallportmaster" Content="Portmaster" Margin="5,0" ToolTip="Gestor de transit d''internet"/>
                                <CheckBox Name="WPFInstallwireshark" Content="Wireshark" Margin="5,0" ToolTip="Visualitzador del transit d''internet"/>
                            </StackPanel>
                            <StackPanel Background="{MainBackgroundColor}" SnapsToDevicePixels="True" Grid.Row="1" Grid.Column="3" Margin="9">
                                <Label Content="Utilitats" FontSize="16" Margin="5,0"/>
                                <CheckBox Name="WPFInstallzip" Content="7-Zip" Margin="5,0" ToolTip="Descompressor d''arxius"/>
                                <CheckBox Name="WPFInstallpeazip" Content="PeaZip" Margin="5,0"  ToolTip="Descompressor d''arxius"/>
                                <CheckBox Name="WPFInstallbleachbit" Content="BleachBit" Margin="5,0" ToolTip="Netejador de disc"/>
                                <CheckBox Name="WPFInstallexplorer" Content="Double Commander" Margin="5,0" ToolTip="Explorador de fitxers"/>
                                <CheckBox Name="WPFInstallwindir" Content="WinDirStat" Margin="5,0" ToolTip="Gestor d''emmagatzematge"/>
                                <CheckBox Name="WPFInstallbulkcrap" Content="Bulk Crap Uninstaller" Margin="5,0" ToolTip="Desinstal.lador de programes"/>
                                <CheckBox Name="WPFInstallrufus" Content="Rufus" Margin="5,0" ToolTip="Bootable USB"/>
                                <CheckBox Name="WPFInstallrustdesk" Content="RustDesk" Margin="5,0" ToolTip="Escriptori remot"/>
                                <CheckBox Name="WPFInstallautohotkey" Content="AutoHotKey" Margin="5,0" ToolTip="Scrips de teclat"/>
                            </StackPanel>
                            <StackPanel Background="{MainBackgroundColor}" Orientation="Horizontal" Grid.Row="0" HorizontalAlignment="Center" Grid.Column="2" Grid.ColumnSpan="2" Margin="8">
                                <TextBlock Padding="5">
                                    Passa el punter per sobre dels noms per obtindre una descripcio.
                                </TextBlock>
                            </StackPanel>
                        </Grid>
                    </TabItem>
                </TabControl>
            </Grid>
        </Viewbox>
    </Border>
</Window>'
$sync.configs.applications = '{
  "WPFInstallfirefox":{
    "winget":"Mozilla.Firefox"
  },
  "WPFInstalllibrewolf":{
    "winget":"LibreWolf.LibreWolf"
  },
  "WPFInstallchromium":{
    "winget":"eloston.ungoogled-chromium"
  },
  "WPFInstallbrave":{
    "winget":"Brave.Brave"
  },
  "WPFInstallonlyoffice":{
    "winget":"ONLYOFFICE.DesktopEditors"
  },
  "WPFInstalllibreoffice":{
    "winget":"TheDocumentFoundation.LibreOffice"
  },
  "WPFInstallwinmerge":{
    "winget":"WinMerge.WinMerge"
  },
  "WPFInstallscribus":{
    "winget":"Scribus.Scribus"
  },
  "WPFInstallsumatra":{
    "winget":"SumatraPDF.SumatraPDF"
  },
  "WPFInstalljoplin":{
    "winget":"Joplin.Joplin"
  },
  "WPFInstallvlc":{
    "winget":"VideoLAN.VLC"
  },
  "WPFInstallobs":{
    "winget":"OBSProject.OBSStudio"
  },
  "WPFInstallspotube":{
    "winget":"KRTirtho.Spotube"
  },
  "WPFInstallcider":{
    "winget":"CiderCollective.Cider"
  },
  "WPFInstalldownloader":{
    "winget":"subhra74.XtremeDownloadManager"
  },
  "WPFInstallaudacity":{
    "winget":"Audacity.Audacity"
  },
  "WPFInstallgimp":{
    "winget":"GIMP.GIMP"
  },
  "WPFInstallkrita":{
    "winget":"KDE.Krita"
  },
  "WPFInstalldarktable":{
    "winget":"darktable.darktable"
  },
  "WPFInstallinkscape":{
    "winget":"Inkscape.Inkscape"
  },
  "WPFInstallcaesium":{
    "winget":"SaeraSoft.CaesiumImageCompressor"
  },
  "WPFInstallkdenlive":{
    "winget":"KDE.Kdenlive"
  },
  "WPFInstallhandbrake":{
    "winget":"HandBrake.HandBrake"
  },
  "WPFInstallblender":{
    "winget":"BlenderFoundation.Blender"
  },
  "WPFInstallfreecad":{
    "winget":"FreeCAD.FreeCAD"
  },
  "WPFInstallcodium":{
    "winget":"VSCodium.VSCodium"
  },
  "WPFInstallnotepad":{
    "winget":"Notepad++.Notepad++"
  },
  "WPFInstallplaynite":{
    "winget":"Playnite.Playnite"
  },
  "WPFInstallheroic":{
    "winget":"HeroicGamesLauncher.HeroicGamesLauncher"
  },
  "WPFInstallitchio":{
    "winget":"ItchIO.Itch"
  },
  "WPFInstallclamwin":{
    "winget":"ClamWin.ClamWin"
  },
  "WPFInstalleraser":{
    "winget":"Eraser.Eraser"
  },
  "WPFInstallchecksum":{
    "winget":"namazso.OpenHashTab"
  },
  "WPFInstallkeepass":{
    "winget":"KeePassXCTeam.KeePassXC"
  },
  "WPFInstallsandbox":{
    "winget":"Sandboxie.Plus"
  },
  "WPFInstallportmaster":{
    "winget":"Safing.Portmaster"
  },
  "WPFInstallwireshark":{
    "winget":"WiresharkFoundation.Wireshark"
  },
  "WPFInstallzip":{
    "winget":"7zip.7zip"
  },
  "WPFInstallpeazip":{
    "winget":"Giorgiotani.Peazip"
  },
  "WPFInstallbleachbit":{
    "winget":"BleachBit.BleachBit"
  },
  "WPFInstallexplorer":{
    "winget":"alexx2000.DoubleCommander"
  },
  "WPFInstallwindir":{
    "winget":"WinDirStat.WinDirStat"
  },
  "WPFInstallbulkcrap":{
    "winget":"Wingetcommand"
  },
  "WPFInstallrufus":{
    "winget":"Rufus.Rufus"
  },
  "WPFInstallrustdesk":{
    "winget":"RustDesk.RustDesk"
  },
  "WPFInstallautohotkey":{
    "winget":"AutoHotkey.AutoHotkey"
  }
}' | convertfrom-json
$sync.configs.themes = '{
    "Classic":  {
                    "ComboBoxBackgroundColor":  "#777777",
                    "LabelboxForegroundColor":  "#000000",
                    "MainForegroundColor":  "#000000",
                    "MainBackgroundColor":  "#777777",
                    "LabelBackgroundColor":  "#777777",
                    "ComboBoxForegroundColor":  "#000000",
                    "ButtonInstallBackgroundColor":  "#222222",
                    "ButtonTweaksBackgroundColor":  "#333333",
                    "ButtonConfigBackgroundColor":  "#444444",
                    "ButtonUpdatesBackgroundColor":  "#555555",
                    "ButtonInstallForegroundColor":  "#FFFFFF",
                    "ButtonBackgroundColor":  "#CACACA",
                    "ButtonBackgroundPressedColor":  "#FFFFFF",
                    "ButtonBackgroundMouseoverColor":  "AliceBlue",
                    "ButtonForegroundColor":  "#000000",
                    "ButtonBorderThickness":  "0",
                    "ButtonMargin":  "0,3,0,3",
                    "ButtonCornerRadius": "0"
                },
    "Matrix":  {
                   "ComboBoxBackgroundColor":  "#000000",
                   "LabelboxForegroundColor":  "#FFEE58",
                   "MainForegroundColor":  "#9CCC65",
                   "MainBackgroundColor":  "#000000",
                   "LabelBackgroundColor":  "#000000",
                   "ComboBoxForegroundColor":  "#FFEE58",
                   "ButtonInstallBackgroundColor":  "#222222",
                   "ButtonTweaksBackgroundColor":  "#333333",
                   "ButtonConfigBackgroundColor":  "#444444",
                   "ButtonUpdatesBackgroundColor":  "#555555",
                   "ButtonInstallForegroundColor":  "#FFFFFF",
                   "ButtonBackgroundColor":  "#000000",
                   "ButtonBackgroundPressedColor":  "#FFFFFF",
                   "ButtonBackgroundMouseoverColor":  "#A55A64",
                   "ButtonForegroundColor":  "#9CCC65",
                   "ButtonBorderThickness":  "3",
                   "ButtonMargin":  "2",
                   "ButtonCornerRadius": "4"
               }
}' | convertfrom-json
# SPDX-License-Identifier: MIT

#Configure max thread count for RunspacePool.
$maxthreads = [int]$env:NUMBER_OF_PROCESSORS

#Create a new session state for parsing variables ie hashtable into our runspace.
$hashVars = New-object System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList 'sync',$sync,$Null
$InitialSessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()

#Add the variable to the RunspacePool sessionstate
$InitialSessionState.Variables.Add($hashVars)

#Add functions
$functions = Get-ChildItem function:\ | Where-Object {$_.name -like "*winutil*" -or $_.name -like "*WPF*"}
foreach ($function in $functions){
    $functionDefinition = Get-Content function:\$($function.name)
    $functionEntry = New-Object System.Management.Automation.Runspaces.SessionStateFunctionEntry -ArgumentList $($function.name), $functionDefinition
    
    # And add it to the iss object
    $initialSessionState.Commands.Add($functionEntry)
}

#Create our runspace pool. We are entering three parameters here min thread count, max thread count and host machine of where these runspaces should be made.
$sync.runspace = [runspacefactory]::CreateRunspacePool(1,$maxthreads,$InitialSessionState, $Host)

#Open a RunspacePool instance.
$sync.runspace.Open()

#region exception classes

    class WingetFailedInstall : Exception {
        [string] $additionalData

        WingetFailedInstall($Message) : base($Message) {}
    }

    class GenericException : Exception {
        [string] $additionalData

        GenericException($Message) : base($Message) {}
    }
    
#endregion exception classes

$inputXML = $inputXML -replace 'mc:Ignorable="d"', '' -replace "x:N", 'N' -replace '^<Win.*', '<Window'

$ctttheme = 'Classic'

$inputXML = Set-WinUtilUITheme -inputXML $inputXML -themeName $ctttheme

[void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
[xml]$XAML = $inputXML
#Read XAML

$reader = (New-Object System.Xml.XmlNodeReader $xaml)
try { $sync["Form"] = [Windows.Markup.XamlReader]::Load( $reader ) }
catch [System.Management.Automation.MethodInvocationException] {
    Write-Warning "We ran into a problem with the XAML code.  Check the syntax for this control..."
    Write-Host $error[0].Exception.Message -ForegroundColor Red
    If ($error[0].Exception.Message -like "*button*") {
        write-warning "Ensure your &lt;button in the `$inputXML does NOT have a Click=ButtonClick property.  PS can't handle this`n`n`n`n"
    }
}
catch {
    Write-Host "Unable to load Windows.Markup.XamlReader. Double-check syntax and ensure .net is installed."
}

#===========================================================================
# Store Form Objects In PowerShell
#===========================================================================

$xaml.SelectNodes("//*[@Name]") | ForEach-Object {$sync["$("$($psitem.Name)")"] = $sync["Form"].FindName($psitem.Name)}

$sync.keys | ForEach-Object {
    if($sync.$psitem){
        if($($sync["$psitem"].GetType() | Select-Object -ExpandProperty Name) -eq "Button"){
            $sync["$psitem"].Add_Click({
                [System.Object]$Sender = $args[0]
                Invoke-WPFButton $Sender.name
            })
        }
    }
}


$sync.keys | ForEach-Object {
    if($sync.$psitem){
        if(
            $($sync["$psitem"].GetType() | Select-Object -ExpandProperty Name) -eq "CheckBox" `
            -and $sync["$psitem"].Name -like "WPFToggle*"
        ){
            $sync["$psitem"].IsChecked = Get-WinUtilToggleStatus $sync["$psitem"].Name

            $sync["$psitem"].Add_Click({
                [System.Object]$Sender = $args[0]
                Invoke-WPFToggle $Sender.name
            })
        }
    }
}


#===========================================================================
# Setup background config
#===========================================================================

#Load information in the background
Invoke-WPFRunspace -ScriptBlock {
    $sync.ConfigLoaded = $False

    $sync.ComputerInfo = Get-ComputerInfo

    $sync.ConfigLoaded = $True
} | Out-Null

#===========================================================================
# Shows the form
#===========================================================================

Invoke-WPFFormVariables

$sync["Form"].title = $sync["Form"].title + " " + $sync.version
$sync["Form"].Add_Closing({
    $sync.runspace.Dispose()
    $sync.runspace.Close()
    [System.GC]::Collect()
})

$sync["Form"].ShowDialog() | out-null
Stop-Transcript
